20 important question
1 what is mysql and MongoDB Features const and pros
2 What are the difference between NoSQL and SQL
3 How to establish MongoDB database connection in a node application? mogoose.connection(())
4 What are virtual property in mongoose
5 second highest salary in monggodb
7 join all
8 aggregation pipeline
9 index
11 orm what is meaning pros const object 
12 replica set  practical usecase?
14 What are the mongoose middlewares?  pre or post in schema that is call middlewares
15 How to query data using mongoose?
Trasection
Sharding
Agrregation
Projection
define in mongodb with type ?


MySQL vs. MongoDB: Features, Constraints, and Pros
Both MySQL and MongoDB are popular databases, but they serve different purposes based on the type of application and data structure.

MySQL (Relational Database)
Features:
Structured Data ‚Äì Uses structured tables with fixed schemas.
SQL-Based Queries ‚Äì Uses Structured Query Language (SQL) for data manipulation.
ACID Compliance ‚Äì Supports Atomicity, Consistency, Isolation, and Durability (ACID).
Joins Support ‚Äì Allows complex joins across multiple tables.
Indexing ‚Äì Uses B-trees and hash indexes for faster data retrieval.
Transactions ‚Äì Supports multi-step transactions with rollback capabilities.
Data Integrity ‚Äì Enforces strong consistency with constraints like primary keys, foreign keys, and unique constraints.
Replication & Clustering ‚Äì Supports master-slave and master-master replication.

Constraints (Cons):
Rigid Schema ‚Äì Altering table structure can be complex.
Slower for Unstructured Data ‚Äì Not optimized for large, flexible data models.
Scalability Issues ‚Äì Vertical scaling is costly; horizontal scaling requires sharding.
Performance Bottlenecks ‚Äì Slower than NoSQL for large, read-heavy applications.

Pros:
‚úÖ Best for structured, transactional applications.
‚úÖ High security with strong data consistency.
‚úÖ Excellent for applications needing complex queries and joins.
‚úÖ Ideal for financial, banking, and e-commerce applications.


MongoDB (NoSQL Database)
MongoDB is a NoSQL, document-oriented database that stores data in BSON (Binary JSON) format. It is designed for 
scalability, flexibility, and high performance and is commonly used in modern web applications.

Features:-
Flexible Schema ‚Äì Stores data in JSON-like BSON documents.
NoSQL-Based Queries ‚Äì Uses key-value pairs and document-based queries.
Horizontal Scaling ‚Äì Built for distributed architecture with sharding.
High Write Performance ‚Äì Handles large volumes of unstructured data efficiently.
Replication & Failover ‚Äì Supports automatic failover and replica sets.
Indexing & Aggregation ‚Äì Uses various indexing strategies for faster queries.
Geospatial Queries ‚Äì Supports location-based queries natively.
Automatic Load Balancing ‚Äì Distributes workload across multiple servers.

Constraints (Cons):-
No ACID Transactions (Initially) ‚Äì Though later versions added multi-document transactions, it's not as strong as MySQL.
High Memory Usage ‚Äì Requires more RAM for optimal performance.
Limited Joins ‚Äì Complex queries involving multiple collections require aggregation pipelines.
Data Redundancy ‚Äì No strict normalization like MySQL, leading to potential duplication.

Pros:
‚úÖ Best for dynamic and semi-structured data.
‚úÖ Scales horizontally, making it ideal for big data and cloud applications.
‚úÖ High-speed performance for read and write operations.
‚úÖ Suitable for real-time analytics, IoT, and content management systems.

When to Choose MySQL vs. MongoDB?
Choose MySQL if your application requires strong consistency, structured relationships, and ACID compliance (e.g., banking, finance, ERP).
Choose MongoDB if your application needs high flexibility, scalability, and fast performance for large volumes of unstructured data (e.g., real-time analytics, social media, IoT).

SQL vs. NoSQL: Key Differences
SQL (Structured Query Language) and NoSQL (Not Only SQL) are two different types of database management systems designed for different use cases. Here's a detailed comparison:

Feature	SQL (Relational Databases)	NoSQL (Non-Relational Databases)
Data Structure	Uses structured tables with predefined schemas (rows & columns).	Uses flexible, schema-less data models like key-value, document, column, or graph.
Schema	        Fixed schema with strict relationships (tables, primary keys, foreign keys).	Dynamic schema; no need for predefined structure.
Query Language	Uses SQL (Structured Query Language) for querying and data manipulation.	Uses JSON-like queries, key-value access, or graph-based queries (depends on database type).
Scalability	    Scales vertically (adding more power to a single server).	Scales horizontally (distributing data across multiple servers).
Transactions	  Supports ACID (Atomicity, Consistency, Isolation, Durability) properties.	Often uses BASE (Basically Available, Soft state, Eventually consistent) model.
Joins & Relationships	
Strong support  for joins and foreign keys, ensuring relational integrity.	Limited or no support for joins; relationships handled at the application level.
Performance	    Can slow down with large, complex queries (especially read-heavy workloads).	Faster for read/write-heavy applications due to denormalized structure.
Flexibility	Less flexible‚Äîchanging schema requires migration.	Highly flexible‚Äîschema can evolve over time.
Best Use Cases	Financial systems, CRM, ERP, inventory management, e-commerce.	Big data, real-time analytics, IoT, social media, recommendation engines.


dump database 
mongodump --username your_username --password your_password --authenticationDatabase admin --out /path/to/output/directory
or
mongodump --uri="mongodb://13.127.232.191:21819 /vedobi" --forceTableScan
restore:-


virtual properties allow you to define computed or derived properties on your Mongoose models. 
These virtual properties do not exist in the MongoDB document stored in the database; 
instead, they are calculated on the fly when you access them.

example:-
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
});

// Define a virtual property called 'fullName'
userSchema.virtual('fullName').get(function () {
  return `${this.firstName} ${this.lastName}`;
});
 
const User = mongoose.model('User', userSchema);


Embedded documents
nested documents or Embedded documents max 100
one document size  max is 16mb not exeed more that


// Find the second highest salary
1st method
db.employees.aggregate([
  { $group: { _id: "$salary" } },  // Group by unique salaries
  { $sort: { _id: -1 } },          // Sort salaries in descending order
  { $skip: 1 },                    // Skip the highest salary
  { $limit: 1 }                     // Get the second highest salary
]);

const highestSalary = await collection.findOne({}, { sort: { salary: -1 }, projection: { salary: 1, _id: 0 } });
const secondHighestSalary = await collection.find({ salary: { $lt: highestSalary } })
  .sort({ salary: -1 })
  .limit(1)
  .toArray();
  console.log('Second Highest Salary:', secondHighestSalary[0]?.salary);


nosql database Mongodb
1  redis key value base
2. casandra columns base big data
3. Mongodb document base 
4. Graphql graph base 


aggregation in Mongodb:-
The Aggregation Pipeline in MongoDB is a powerful feature that allows you to process and transform documents in a collection. 
It works by passing documents through multiple stages, where each stage performs an operation like filtering, grouping, or sorting.

Why Use Aggregation Pipeline?
‚úÖ Efficient Data Processing ‚Äì Perform complex operations on large datasets efficiently.
‚úÖ Data Transformation ‚Äì Convert, filter, and modify data before retrieving it.
‚úÖ Analytics & Reporting ‚Äì Aggregate data for analytics like total sales, average ratings, etc.

Basic Structure of Aggregation Pipeline:-
Operator	Description
$match	Filters documents (like WHERE in SQL)
$group	Groups data and applies aggregate functions like $sum, $avg, $max, $min
$project	Reshapes documents, includes/excludes fields
$sort	Sorts documents (1 for ascending, -1 for descending)
$limit	Limits the number of documents returned
$skip	Skips a number of documents
$unwind	Deconstructs an array into multiple documents
$lookup	Performs a JOIN between collections


example:- sales
[
  { "_id": 1, "product": "Laptop", "quantity": 4, "price": 1000 },
  { "_id": 2, "product": "Phone", "quantity": 10, "price": 500 },
  { "_id": 3, "product": "Laptop", "quantity": 5, "price": 1000 },
  { "_id": 4, "product": "Phone", "quantity": 8, "price": 500 },
  { "_id": 5, "product": "Tablet", "quantity": 6, "price": 600 }
]

db.sales.aggregate([
  {
    $group: {
      _id: "$product",              // Group by 'product'
      totalQuantity: { $sum: "$quantity" }, // Sum the 'quantity' for each group
      averagePrice: { $avg: "$price" }      // Calculate the average 'price' for each group
    }
  }
])

output:-
[
  { "_id": "Laptop", "totalQuantity": 9, "averagePrice": 1000 },
  { "_id": "Phone", "totalQuantity": 18, "averagePrice": 500 },
  { "_id": "Tablet", "totalQuantity": 6, "averagePrice": 600 }
]



replication or replica set (it's a all databases combination)
duplicate of server data asynchoronous manner

Key Components of a Replica Set
Primary Node ‚Äì Handles read and write operations.
Secondary Nodes ‚Äì Replicates data from the primary and can be used for read scaling.
Arbiter (Optional) ‚Äì Helps in elections but does not store data.

profit:-
fault tolenrence,  problem solved
read call to second or other but write call to focus to primary server
Benefits of Replica Sets
‚úÖ High Availability ‚Äì If one node fails, another is elected as Primary.
‚úÖ Data Redundancy ‚Äì Copies of data exist on multiple nodes.
‚úÖ Read Scalability ‚Äì Secondary nodes can handle read requests.
‚úÖ Automatic Failover ‚Äì No manual intervention required for switching roles.



Sharding:-
Sharding is horizontal database partitioning that helps distribute data across multiple servers to improve performance and scalability. 
It is used when a single MongoDB server cannot handle large amounts of data or traffic efficiently.
Sharding or shard ( using load balancer) handle of user traffic  (using Horizontal Scaling)
Sharding is a data distribution process and stores a single data set into multiple database using Round-Robin algo 
Vertical scalling adding more resourses as on demand
Horizontal scalling adding more processing or physical machine\

Why Use Sharding?
‚úÖ Supports large-scale applications
‚úÖ Improves read/write performance
‚úÖ Handles high traffic loads
‚úÖ Distributes queries across multiple machines


projection:-
Projection in MongoDB is used to select specific fields from a document instead of retrieving the entire document. This helps in 
reducing data transfer, improving query performance, and optimizing
db.collection_name.find({}, key: 1)

{_id: 87455431577, title: "ksisis"},
{_id: 87455478797, title: "rahls"},
{_id: 87455478897, title: "how are you"},

only display the title 
db.collection_name.find({}, title: 1, _id: 0)

show all document only key title not others
{title: "ksisis"},
{title: "rahul"},
{title: "how are you"},



indexing:-
createIndex()
db.collection_name.createIndex({title: 1, description: -1})  //1 true, -1 false 
db.collection_name.dropIndex({title: 1});


shard key = consists of a field or multiple field
chunks = contains partitioned data or subsets of shared data.
balancer = responsible for evently distribution of equal chunks across shards
zones = can help to improve the data locality for shared clusters.

less relationships
nested each document size 16mb
object inside array find query get data
db.find({hobbies:"dance"})  //all document which is dance hobbies


Mongodb data modeling


Using $lookup to Join orders and customers:
orders:-
[
  { "_id": 1, "orderDate": "2024-09-01", "customerId": 1001, "total": 250 },
  { "_id": 2, "orderDate": "2024-09-02", "customerId": 1002, "total": 450 },
  { "_id": 3, "orderDate": "2024-09-03", "customerId": 1001, "total": 300 }
]

customers:-
[
  { "_id": 1001, "name": "aijaj", "email": "aijaj@example.com" },
  { "_id": 1002, "name": "prabind", "email": "prabind@example.com" }
]

query:-
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",          // Collection to join (customers)
      localField: "customerId",   // Field from orders (customerId)
      foreignField: "_id",        // Field from customers (_id)
      as: "customerDetails"       // Name of the output array field
    }
  }
])

output:-
[
  {
    "_id": 1,
    "orderDate": "2024-09-01",
    "customerId": 1001,
    "total": 250,
    "customerDetails": [
      { "_id": 1001, "name": "John Doe", "email": "john@example.com" }
    ]
  },
  {
    "_id": 2,
    "orderDate": "2024-09-02",
    "customerId": 1002,
    "total": 450,
    "customerDetails": [
      { "_id": 1002, "name": "Jane Smith", "email": "jane@example.com" }
    ]
  },
  {
    "_id": 3,
    "orderDate": "2024-09-03",
    "customerId": 1001,
    "total": 300,
    "customerDetails": [
      { "_id": 1001, "name": "John Doe", "email": "john@example.com" }
    ]
  }
]




populate:-
customer schema:-
const mongoose = require('mongoose');
const customerSchema = new mongoose.Schema({
  name: String,
  email: String
});
const Customer = mongoose.model('Customer', customerSchema);

order schema:-
const orderSchema = new mongoose.Schema({
  orderDate: Date,
  totalAmount: Number,
  customerId: { type: mongoose.Schema.Types.ObjectId, ref: 'Customer' }
});
const Order = mongoose.model('Order', orderSchema);

query:-
db.Order.find().populate('customerId').then(orders => {
  console.log(orders);
});



unwind:-
students:- [
  {
    "_id": 1,
    "name": "Alice",
    "subjects": ["Math", "Science", "English"]
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": ["History", "Math"]
  },
  {
    "_id": 3,
    "name": "Charlie",
    "subjects": []
  }
]

query:-
db.students.aggregate([
  {
    $unwind: "$subjects"
  }
])

output:-
[
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Math"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Science"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "English"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "History"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "Math"
  }
]

query2:-
db.students.aggregate([
  {
    $unwind: {
      path: "$subjects",
      preserveNullAndEmptyArrays: true
    }
  }
])

output:-
[
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Math"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Science"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "English"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "History"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "Math"
  },
  {
    "_id": 3,
    "name": "Charlie",
    "subjects": null
  }
]


Query Optimization in MongoDB
Optimizing queries in MongoDB is essential to improve performance, reduce response time, and minimize resource usage:




4.Using Covered Queries
5.Avoiding $where and Regex on Non-Indexed Fields
6.Optimizing Aggregation Pipelines
7.Using $exists and $type Efficiently
8.Analyzing Queries with .explain()


1.Using Indexes
db.users.createIndex({ email: 1 });
db.users.find({ email: "user@example.com" });


2.Avoiding Full Collection Scans
Bad Query (No Index)
db.orders.find({ status: "pending" });

To optimize, create an index:
db.orders.createIndex({ status: 1 });


3.Using Projection to Return Only Necessary Fields
Bad Query (Fetching All Fields)
db.users.find({ age: { $gt: 25 }});

3Ô∏è‚É£ Projection with Embedded Documents (Nested Fields)
Sample Collection: employees
[
  {
    "_id": 1,
    "name": "David",
    "contact": { 
      "email": "david@example.com", 
      "phone": "1234567890" 
    }
  }
]
db.users.find({ age: { $gt: 25 } }, { name: 1, email: 1, _id: 0 });



Query Optimization Technique in MongoDB
‚úÖ 1. Use Indexing
  db.users.createIndex({ email: 1 });
After indexing, the query avoids full collection scans.

‚úÖ 2. Use explain() to Analyze Queries
  db.users.find({ age: { $gt: 30 } }).explain("executionStats");
  This shows if MongoDB is scanning the entire collection or using an index.

‚úÖ 3. Fetch Only Required Fields (Projection)
db.users.find({}, { name: 1, email: 1, _id: 0 });
This reduces data transfer.

‚úÖ 4. Use Aggregation Pipeline for Joins	$lookup in Aggregation Complex Queries
db.orders.aggregate([
  { $match: { status: "delivered" } },
  { $group: { _id: "$userId", totalSpent: { $sum: "$price" } } },
  { $sort: { totalSpent: -1 } }
]);
This filters, groups, and sorts efficiently.

‚úÖ 5. Use Query Pagination (limit() and skip())
db.users.find().skip(10).limit(10);
Fetches only 10 records at a time.

‚úÖ 6. Use Connection Pooling
const mongoose = require("mongoose");
mongoose.connect("mongodb://localhost:27017/myDB", {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  poolSize: 10
});
‚úÖ This speeds up multiple concurrent queries.



MySQL vs MongoDB Query Optimization (Comparison)
Optimization Technique	MySQL	MongoDB
Indexing	                ‚úÖ (B-Tree Indexes)	  ‚úÖ (B-Tree, Compound Indexes)
Explain Query Execution	  ‚úÖ (EXPLAIN)	          ‚úÖ (explain())
Limit Result Set	        ‚úÖ (LIMIT)	            ‚úÖ (limit() & skip())
Fetching Specific Columns	‚úÖ (SELECT name, email)‚úÖ (Projection { name: 1, _id: 0 })
Query Caching	            ‚úÖ (query_cache_size)	‚úÖ (Built-in in-memory cache)
Joins vs Embedded Docs	  ‚úÖ (Needs Index for Faster Joins)	‚úÖ (Embedded Documents for Fast Access)
Aggregation	              ‚úÖ (GROUP BY, HAVING)	‚úÖ ($group, $sort, $match)



How to Avoid Multiple null Entries?
If you want null values to be unique (i.e., allow only one null value), you should use:
sparse: true ensures the uniqueness constraint does not apply to null values.
Without sparse, Mongoose enforces a unique index even on null, which can lead to conflicts.

username: { type: String, unique: true, sparse: true }


EXPLAIN() in MySQL and MongoDB (With Examples)
The EXPLAIN command helps analyze how a query is executed, showing details like whether an index is used, if it's performing 
a full table scan, and how much data is processed.


Data Types in MongoDB
1Ô∏è‚É£ String (String)
2Ô∏è‚É£ Number Types
3Ô∏è‚É£ Boolean (Boolean)
4Ô∏è‚É£ Array (Array)
5Ô∏è‚É£ Object (Embedded Document)
6Ô∏è‚É£ ObjectId (ObjectId)
7Ô∏è‚É£ Date (Date)
8Ô∏è‚É£ Null (Null)
9Ô∏è‚É£ Binary Data (BinData)
üîü Regular Expression (RegExp)
1Ô∏è‚É£1Ô∏è‚É£ JavaScript (Code)
1Ô∏è‚É£2Ô∏è‚É£ Timestamp (Timestamp)

example:-
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "name": "John Doe",
  "age": 30,
  "email": "john@example.com",
  "isActive": true,
  "hobbies": ["reading", "gaming"],
  "address": { "city": "New York", "zip": "10001" },
  "createdAt": ISODate("2024-03-23T10:30:00Z"),
  "lastLogin": Timestamp(1711185652, 1),
  "profilePic": BinData(0, "base64_encoded_data")
}
