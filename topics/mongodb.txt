20 important question
1 what is mysql and MongoDB Features const and pros
2 What are the difference between NoSQL and SQL
3 How to establish MongoDB database connection in a node application?
4 What are virtual property in mongoose
5 second highest salary in monggodb
6 migration
7 join all
8 aggregation pipeline
9 index
11 orm what is meaning pros const object 
12 replica set
13 transection
14 What are the mongoose middlewares?  pre or post in schema that is call middlewares
15 How to query data using mongoose?
Trasection
Second highest salary
All join
Sharding
Agrregation
Projection



dump database
mongodump --username your_username --password your_password --authenticationDatabase admin --out /path/to/output/directory
or
mongodump --uri="mongodb://13.127.232.191:21819/vedobi" --forceTableScan
restore:-


virtual properties allow you to define computed or derived properties on your Mongoose models. 
These virtual properties do not exist in the MongoDB document stored in the database; 
instead, they are calculated on the fly when you access them.

example:-
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
});

// Define a virtual property called 'fullName'
userSchema.virtual('fullName').get(function () {
  return `${this.firstName} ${this.lastName}`;
});

const User = mongoose.model('User', userSchema);


Embedded documents
nested documents or Embedded documents max 100
one document size  max is 16mb not exeed more that


// Find the second highest salary
db.employees.aggregate([
  {
    $sort: { salary: -1 }
  },
  {
    $skip: 1
  },
  {
    $limit: 1
  }
]);


const highestSalary = await collection.findOne({}, { sort: { salary: -1 }, projection: { salary: 1, _id: 0 } });
const secondHighestSalary = await collection.find({ salary: { $lt: highestSalary } })
  .sort({ salary: -1 })
  .limit(1)
  .toArray();
  console.log('Second Highest Salary:', secondHighestSalary[0]?.salary);


nosql database Mongodb
1  redis key value base
2. casandra columns base big data
3. Mongodb document base 
4. Graphql graph base 


aggregation in Mongodb:-
aggregation is the process of selecting data from a collection to process multiple documents and returns computed results

group value from multiple documents together
fetching a lots of nested data from performed complex operations
filter and sort documents and analysis data changes

example:- sales
[
  { "_id": 1, "product": "Laptop", "quantity": 4, "price": 1000 },
  { "_id": 2, "product": "Phone", "quantity": 10, "price": 500 },
  { "_id": 3, "product": "Laptop", "quantity": 5, "price": 1000 },
  { "_id": 4, "product": "Phone", "quantity": 8, "price": 500 },
  { "_id": 5, "product": "Tablet", "quantity": 6, "price": 600 }
]

db.sales.aggregate([
  {
    $group: {
      _id: "$product",              // Group by 'product'
      totalQuantity: { $sum: "$quantity" }, // Sum the 'quantity' for each group
      averagePrice: { $avg: "$price" }      // Calculate the average 'price' for each group
    }
  }
])

output:-
[
  { "_id": "Laptop", "totalQuantity": 9, "averagePrice": 1000 },
  { "_id": "Phone", "totalQuantity": 18, "averagePrice": 500 },
  { "_id": "Tablet", "totalQuantity": 6, "averagePrice": 600 }
]



replication or replica set (it's a all databases combination)
duplicate of server data asynchoronous manner
primary and secondary read and write operations in database.
profit:-
fault tolenrence,  problem solved
read call to second or other but write call to focus to primary server


Sharding or shard ( using load balancer) handle of user traffic  (using Horizontal Scaling)
Sharding is a data distribution process and stores a single data set into multiple database.
Vertical scalling adding more resourses as on demand
Horizontal scalling adding more processing or physical machine


projection:-
db.collection_name.find({}, key: 1)

{_id: 87455431577, title: "ksisis"},
{_id: 87455478797, title: "rahls"},
{_id: 87455478897, title: "how are you"},

only display the title 
db.collection_name.find({}, title: 1, _id: 0)

show all document only key title not others
{title: "ksisis"},
{title: "rahls"},
{title: "how are you"},



indexing:-
createIndex()
db.collection_name.createIndex({title: 1, description: -1})  //1 true, -1 false 
db.collection_name.dropIndex({title: 1});


shard key = consists of a field or multiple field
chunks = contains partitioned data or subsets of shared data.
balancer = responsible for evently distribution of equal chunks across shards
zones = can help to improve the data locality for shared clusters.

less relationships
nested each document size 16kb
object inside array find query get data
db.find({hobbies:"dance"})  //all document which is dance hobbies


Mongodb data modeling


Using $lookup to Join orders and customers:
orders:-
[
  { "_id": 1, "orderDate": "2024-09-01", "customerId": 1001, "total": 250 },
  { "_id": 2, "orderDate": "2024-09-02", "customerId": 1002, "total": 450 },
  { "_id": 3, "orderDate": "2024-09-03", "customerId": 1001, "total": 300 }
]

customers:-
[
  { "_id": 1001, "name": "John Doe", "email": "john@example.com" },
  { "_id": 1002, "name": "Jane Smith", "email": "jane@example.com" }
]

query:-
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",          // Collection to join (customers)
      localField: "customerId",   // Field from orders (customerId)
      foreignField: "_id",        // Field from customers (_id)
      as: "customerDetails"       // Name of the output array field
    }
  }
])

output:-
[
  {
    "_id": 1,
    "orderDate": "2024-09-01",
    "customerId": 1001,
    "total": 250,
    "customerDetails": [
      { "_id": 1001, "name": "John Doe", "email": "john@example.com" }
    ]
  },
  {
    "_id": 2,
    "orderDate": "2024-09-02",
    "customerId": 1002,
    "total": 450,
    "customerDetails": [
      { "_id": 1002, "name": "Jane Smith", "email": "jane@example.com" }
    ]
  },
  {
    "_id": 3,
    "orderDate": "2024-09-03",
    "customerId": 1001,
    "total": 300,
    "customerDetails": [
      { "_id": 1001, "name": "John Doe", "email": "john@example.com" }
    ]
  }
]




populate:-
customer schema:-
const mongoose = require('mongoose');
const customerSchema = new mongoose.Schema({
  name: String,
  email: String
});
const Customer = mongoose.model('Customer', customerSchema);

order schema:-
const orderSchema = new mongoose.Schema({
  orderDate: Date,
  totalAmount: Number,
  customerId: { type: mongoose.Schema.Types.ObjectId, ref: 'Customer' }
});
const Order = mongoose.model('Order', orderSchema);

query:-
db.Order.find().populate('customerId').then(orders => {
  console.log(orders);
});



unwind:-
students:-
[
  {
    "_id": 1,
    "name": "Alice",
    "subjects": ["Math", "Science", "English"]
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": ["History", "Math"]
  },
  {
    "_id": 3,
    "name": "Charlie",
    "subjects": []
  }
]

query:-
db.students.aggregate([
  {
    $unwind: "$subjects"
  }
])

output:-
[
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Math"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Science"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "English"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "History"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "Math"
  }
]

query2:-
db.students.aggregate([
  {
    $unwind: {
      path: "$subjects",
      preserveNullAndEmptyArrays: true
    }
  }
])

output:-
[
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Math"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "Science"
  },
  {
    "_id": 1,
    "name": "Alice",
    "subjects": "English"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "History"
  },
  {
    "_id": 2,
    "name": "Bob",
    "subjects": "Math"
  },
  {
    "_id": 3,
    "name": "Charlie",
    "subjects": null
  }
]









