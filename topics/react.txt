life cycle method:-
constructor:-
before loading execute.

funcion base component useEffect:-
useState()
return()
useEffect()


class base component life cycle method:-
constructor
rendor
componentdidmount  -- first time loading    //useEffect  mounting birth  we should api call and async process in this phase 
componentDidUpdate   -- update time load
componentDidUnmount   --remove from component  dead phase

example:-
componentDidMount()=>{
  console.log("first time loading then call this function, componentDidMount working here...")
}

componentDidUpdate()=>{
  console.log(" when anyupdate call this function,  componentDidUpdate is working here...)
}

componentDidUnmount=()=>{
  console.log("when you will remove any component then it will call this function working...   component remove..")
}



function base component life cycle method:-
//componentDidMount phase
useEffect(()=>{
  console.log("componentDimount is working...")
})


//update phase
useEffect((number)=>{
  console.log("componentDimount is working...")
}, [number])


//remove component phase:-
useEffect((number)=>{
  console.log("function component updating is working...")
  return ()=>{
    console.log("function component removing here...")
  }
}, [number]);


cleanup function




2 hoc(higher order component)
when component pas as a props input component and return output component that is call hoc
when component pass as argument of funcion return inside function thats call hoc
a hoc is a advanced technique in React for reusing component logic.
a hoc is third party react library.
a hoc is funcion that take a component and returns a new component.

why use hoc?
same logic  when we use same component logic different component so we used hoc.





const subjects= (STUDENT)=>{ //component name as arg
  class Subject extends Componet{
    rendor(){
      return (
        <STUDENT hocsub="Java"></STUDENT>
      )
    }
  }
  return Subject;
}

export default subjects;


7 hooks:-
useState
useEffect
useRef  //read deep
useContext
useReducer
useMemo
useCallback

two type of hooks
1 inbuild hooks
  Basic
  adddtional

  Basic Hooks
      useState() state management within particular component 
      useContext()  //state management global access
      useEffect() life cycle method

  Additional Hooks:-
      useRef()      :- blur color   
      useReducer()  :- using redux thunk
      useCallback() :- memoize the function
      useMemo()     :- memoize the value
      useLayoutEffect():- 

2. customHooks



useCallback
function store in cache same useMemo funcionality in funcion
memoized function
memoize the function
code optimization handle  performance manage stop loop or rerendor 
optimization component reredering
refrential equality of function
application well performance 
unwantage function call ko rokne ke liye
unnessessary funcion call ko rokne ke liye


useMemo():-
1 well application performance from cache
2 result ko cache me store kar raha hai next time wo caches se utha lega
3 unwantage function call not use event call so use memo
  memoize the function value
  code optimization handle
  optimization component reredering
  refrential equality of function


useContext:-
  data pass multiple level grandparent to child
  instead of redux for data pass
  component a pass to component b pass component c;
  prop drilling se bachne ke lite useContext() use karte hai


useReducer:-
  state management
  and use redux
  action with dispatch

 
useRef:- when click then highlight color
  rerender do't lost state object 
  access dom property or funcion
  rerender component stop unwantage reredering
  style color focus value etc handle using hooks
  it like a useState only and its preserve the value. No rerender
  use ref change property

  form validation, colors, focus while use only emergency

function CustomTextInput(props) {
  // textInput must be declared here so the ref can refer to it
  const textInput = useRef(null);
  
  function handleClick() {
    textInput.current.focus();
    textInput.current.style.display="none"
  }

  return (
    <div>
      <input
        type="text"
        ref={textInput} />
      <input
        type="button"
        value="Focus the text input"
        onClick={handleClick}
      />
    </div>
  );
}



redux:-
first phase:-
1.prop drilling a component data pass to b component data pass to c component 
child to parent prop data pass


2. react hooks
with redux we can use

3.redux store:-
about redux:-
redux is a patern and library for manageing and updating application state using events called "action". 
It serve as centrallized store for state that needs to be used across your entire application.
state can only be updated in a predictable fasshion.


1. action:-
what i do?

2. reducer:
how to do?

3. store:-
all the data store

function assoicated with store:
data pass child to parent help using redux:-



23oct 2022
props:-
used for data pass one component to another component

state:-
state varible use manage state or updating state


jsx:-
its all html in component inside html in js used thats called jsx(html js ka mukut)


conditional rendering:-
const { useState, useEffect } = React;
const TodoRemaining = () => <div>Remaining</div>;
const TodoDone = () => <div>Done</div>;

const TodoDisplay = () => {
  const [isPreview, setIsPreview] = useState(true);

  return (
    <div>
      {isPreview ? <TodoRemaining /> : <TodoDone />}
      <label htmlFor="change">
        <input
          type="checkbox"
          id="change"
          onChange={() => setIsPreview(!isPreview)}
        />
        Change
      </label>
    </div>
  );
};

export default TodoDisplay;


//list key special key for update or deleting particular item.
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <ListItem key={number.toString()} value={number} />
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}


bind or arrow use function onClick function call.
example:-

<button onClick={this.increment.bind(this)}> click me </button>  //es5
<button onClick={()=>{this.increment()}}> click me </button>     //es6


//composing
same component different props or data use compositing as work inheritance
reuse multiple component 


webpack:-
bundal of information don't go other side
compiler bebel


dom
its is a object presentation of the html document in tree structure in browser
document  html document not pdf document
object   element like h2 body head tag or object or element
model all dom presentation organized way  || completed html document
 
virtual dom:-
virtual dom is replica of original dom its a copy of original dom
and modification any particular things




//pratical
advannce hooks
life cycle method
useContext
Additional Hooks
composing
webpack or babel





controle component
input field can be control  by react state like useState() control
using useState
state can be predictable

uncontrole
use useRef 
input field honi chahiye
input field can be control by useRef() or javascript document like document.getElmentBy
state can not be predictable.




life cycle method:-
useState():-
state change particular component change

useEffect(()=>{
  console.log("hello calling again to again console")
})

calling on screen load only
useEffect(()=>{
  console.log("only once time  console")
}, [])


//depend on change in value
useEffect(()=>{
  console.log("depend on change in value")
}, [value])


useReducer useMemo useCallback Remaining


shadow dom :=
main dom ke ander hidden dom hota hai bahar wale dom ka style design ka impact nhi aata hai use hi
shodow dom kahte hai.
why?
if class match then overwrite


fetch vs axios:-
fetch:-
json.stringfy()
fetch me two parameter(url, option)
after response convert to json.stringfy()
body: me json.stringfy()  data pass hota hai

axios:-
only one parameter(option)
data: normal object;
response status.code we can error handle click easily.





funcion pass as a props:-



31 december
react.new for browser open s
react framework  next.js and remix


fragment use for remove extra div like child colum remove div


pure component is a class component like useMemo
it work like stop re-rendering multi time.
if name is same onClick function then they are not re-render component.

pure component example


useSearchParams() // for query data get


outLet:- is related to nested routing.
 


project:-
timer
todo
qustion answer
basic bill calculate



inverse data flow or child to parent data pass
