Vertical Scaling vs Horizontal Scaling (With Examples)
Scaling is the process of increasing system capacity to handle more traffic or workload. There are two main types of scaling:

1️⃣ Vertical Scaling (Scaling Up)
Increases the power of a single machine (CPU, RAM, Disk, etc.).
Does not require code changes but has hardware limitations.

🖥 Example: Vertical Scaling in MySQL
Before Scaling:-
A MySQL database runs on a 4-core, 8GB RAM server.
It starts slowing down due to high queries.

After Scaling Up:-
Upgrade to a 16-core, 64GB RAM server.
Queries execute faster because of better hardware.

✅ Pros:
✔️ Simple to implement.
✔️ No change in database architecture.

❌ Cons:
❌ Expensive hardware upgrades.
❌ Single point of failure (one server).

2️⃣ Horizontal Scaling (Scaling Out)
Adds more machines (nodes) to distribute the load.
Uses load balancers and replication techniques.

🖥 Example: Horizontal Scaling in MongoDB
Before Scaling
A MongoDB instance runs on one server and handles 1M requests/day.
Performance drops as requests increase.

After Scaling Out
Add 3 more MongoDB servers and use sharding.
Each server stores part of the data (e.g., users A-M on one server, N-Z on another).

✅ Pros:
✔️ Infinite scalability.
✔️ High availability (if one server fails, others handle traffic).

❌ Cons:
❌ Requires load balancing.
❌ More complex architecture.




Difference between WHERE and HAVING Clause in SQL
Both WHERE and HAVING clauses are used to filter data in SQL, but they serve different purposes and operate at different stages of query processing:

WHERE Clause
Purpose: Filters rows before any grouping or aggregation is performed.
Usage: Used to specify conditions on individual rows.
Example:-
SELECT *
FROM employees
WHERE salary > 5000;


HAVING Clause
Purpose: Filters aggregated results after the GROUP BY clause is applied.
Usage: Used to specify conditions on aggregated data (e.g., SUM, COUNT, AVG).
Example:-
SELECT department, COUNT(*) AS employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;

Combined Usage Example
Often, both WHERE and HAVING are used in the same query:

SELECT department, AVG(salary) AS avg_salary, COUNT(*) AS employee_count
FROM employees
WHERE salary IS NOT NULL
GROUP BY department
HAVING AVG(salary) > 6000;

explain:-
WHERE Clause: Filters out rows where salary is NULL.
GROUP BY Clause: Groups the remaining rows by department.
Aggregation: Calculates the average salary (AVG(salary)) and employee count (COUNT(*)) for each department.
HAVING Clause: Filters out groups (departments) where the average salary is not greater than 6000.



What is Migration?
Database migration is the process of changing, transferring, or updating a database schema or data while ensuring minimal downtime. It is commonly used to:
Modify table structures (adding/removing columns, changing types).
Migrate data between different databases (e.g., MySQL → PostgreSQL).
Version control the database schema using migration tools.


What is Database Normalization?
Normalization is the process of organizing a database to reduce data redundancy and improve data integrity. It involves structuring 
the tables and their relationships to minimize duplication and ensure logical data dependencies. The goal is to design a schema 
that avoids anomalies during insert, update, or delete operations. 


primary, unique key and forign key?
primary key:-
Cannot contain NULL values.
Every table should have one primary key.
A primary key automatically creates a clustered index in most databases
its auto increament

unique key:-
Ensures that all values in the column are unique, but null values are not allowed.
Can contain one or more NULL values.
a column or set of columns must be unique, but it's not required to identify a record.


Key Differences:-
Feature	Primary Key vs Unique Constraint
Uniqueness	Must be unique
Nullability	Cannot contain NULL values	Can contain NULL values
Number per Table Only one primary key per table	Multiple unique constraints per table
Purpose	Used to uniquely identify each record Used to ensure unique values in a column
Index Type	Usually creates a clustered index Usually creates a non-clustered index


Key Differences:
Feature	DROP DELETE	TRUNCATE
Removes	Entire table (or object)	Specific rows or all rows	All rows from the table
Table structure	Table is removed entirely	Table remains intact	Table remains intact
Rollback	Generally, cannot be rolled back	Can be rolled back (in a transaction)	Depends on DBMS
Logging	Not logged	Logs each row deletion	Doesn't log individual rows
Speed	Slow for large tables (depends)	Slower for large datasets	Faster for large datasets
Condition	Cannot specify a condition	Can specify a WHERE condition	No condition; removes all rows
Foreign Key Check	Fails if there are dependent FK	Complies with FK checks	Ignores FK constraints in some DBMS

Summary:
DROP: Permanently removes a table or object, including structure and data.
DELETE: Removes specific rows or all rows but keeps the table structure.
TRUNCATE: Quickly removes all rows but keeps the table structure; faster than DELETE for large datasets.


groupby
sales Table:
id	product_name	quantity	price	sale_date
1	Apple	10	1.00	2024-09-01
2	Banana	5	0.50	2024-09-01
3	Apple	3	1.00	2024-09-02
4	Orange	8	0.80	2024-09-02
5	Banana	6	0.50	2024-09-03

query:-
SELECT product_name, SUM(quantity) AS total_quantity FROM sales
GROUP BY product_name;

Result:-
product_name	total_quantity
Apple	            13
Banana	            11
Orange	            8


having query:-
SELECT product_name, SUM(quantity) AS total_quantity FROM sales
GROUP BY product_name HAVING total_quantity > 10;

Result:
product_name	total_quantity
Apple	13
Banana	11



index use:-
create index studdob On students (dob); add multiple columns  //create index
show index from students;         //show index
drop index studdob On students;



table multiple case
UPDATE db.Table1 SET col2 = (CASE col2 WHEN 1 THEN 0 ELSE 1 END);


//second highest salary
SELECT MAX(amount) from salary_stuctures ss1
WHERE amount < (SELECT MAX(amount) from salary_stuctures ss2 ); 


join example:-
right
left
full join
inner join
self
CARTESIAN join (CROSS JOIN)

IN Operator
SELECT * FROM Customers
WHERE Country IN ('Germany', 'France', 'UK');

The SQL BETWEEN Operator
SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20;

The SQL COUNT(), AVG() and SUM() Functions


SQL HAVING Examples  //multiple row use having and single row where used
SELECT COUNT(CustomerID), Country FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5;


what is orm meaning pros const with example?
ORM (Object-Relational Mapping) is a technique that allows developers to interact with a relational database 
(e.g., PostgreSQL, MySQL, MongoDB) using object-oriented programming instead of writing raw SQL queries.

Why Use ORM? (Advantages Over Raw SQL)
✅ 1. Easier & Cleaner Code (No Need for Raw SQL Queries)
ORM allows you to interact with the database using objects instead of complex SQL queries.

SELECT employees.id, employees.name, departments.department_name
FROM employees
INNER JOIN departments
ON employees.department_id = departments.id;


transection:-
In MySQL, a transaction is a sequence of one or more SQL operations that are executed as a single unit. 
Transactions allow you to group SQL statements so that they are all executed together successfully or none at all. 
This ensures data integrity, especially in operations that involve multiple steps, 
where a failure in one step should prevent other steps from committing.
Transaction Control Statements in MySQL:-
    1. START TRANSACTION: Begins a new transaction.
    2. COMMIT: Saves all changes made within the transaction permanently to the database.
    3. ROLLBACK: Undoes all changes made within the transaction, reverting to the initial state.


Key Properties of Transactions:-
Atomicity: Ensures all operations within a transaction complete successfully or none do.
            The entire transaction is treated as a single unit.
            If one part fails, the entire transaction fails.
Consistency: Ensures the database remains in a consistent state before and after the transaction.
            A transaction brings the database from one valid state to another valid state.
Isolation: Ensures that transactions are executed independently of one another.
Durability: Once a transaction is committed, its results are permanent.


Consider a banking application where you need to transfer money from one account to another. The transfer involves two operations:
Deducting the amount from the sender’s account
Adding the amount to the receiver’s account

example:-
-- Start the transaction
START TRANSACTION;

-- Step 1: Deduct amount from sender's account
UPDATE accounts 
SET balance = balance - 100 
WHERE account_no = 1;

-- Step 2: Add amount to receiver's account
UPDATE accounts 
SET balance = balance + 100 
WHERE account_no = 2;

-- If both operations succeed, commit the transaction
COMMIT;



If there’s an error in either step, you can ROLLBACK the transaction to ensure data integrity:
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 100 
WHERE account_id = 1;

-- Intentional error (for example, trying to update a non-existent account)
UPDATE accounts 
SET balance = balance + 100 
WHERE account_id = 999;  -- This account_id does not exist

-- Rollback if any statement fails
ROLLBACK;


The SQL LIKE clause is used to compare a value to similar values using wildcard operators. There are two wildcards used in
conjunction with the LIKE operator.
• The percent sign (%)
• The underscore (_)
The percent sign represents zero, one or multiple characters. The underscore represents a single number or character. These
symbols can be used in combinations.



1. The percent sign (%)
Matches one or more characters.
Note − MS Access uses the asterisk (*) wildcard character instead of the percent sign (%) wildcard character.
2. The underscore (_)
Matches one character.
Note − MS Access uses a question mark (?) instead of the underscore (_) to match any one character



all query:-
1
WHERE SALARY LIKE '200%'
Finds any values that start with 200.
2
WHERE SALARY LIKE '%200%'
Finds any values that have 200 in any position.
3
WHERE SALARY LIKE '_00%'
Finds any values that have 00 in the second and third positions.
4
WHERE SALARY LIKE '2_%_%'
Finds any values that start with 2 and are at least 3 characters in length.
5
WHERE SALARY LIKE '%2'
Finds any values that end with 2.
6
WHERE SALARY LIKE '_2%3'
Finds any values that have a 2 in the second position and end with a 3.
7
WHERE SALARY LIKE '2___3'
Finds any values in a five-digit number that start with 2 and end with 3.

having me where clouse






UNION: Removes duplicate rows and returns only distinct results.
UNION ALL: Includes all records, even duplicates.

Employee Table
id	name	department
1	John	HR
2	Alice	IT
3	Bob	IT

Manager Table
id	name	department
1	John	HR
4	Sarah	Finance

Using UNION:-
SELECT name, department FROM Employee
UNION
SELECT name, department FROM Manager;

Output (Distinct Results)
name	department
John	HR
Alice	IT
Bob	IT
Sarah	Finance


Using UNION ALL
SELECT name, department FROM Employee
UNION ALL
SELECT name, department FROM Manager;
Output (All Rows Including Duplicates)

name	department
John	HR
Alice	IT
Bob	IT
John	HR
Sarah	Finance


1. 2nd highest Salary :
Syntax:
SELECT MAX(SALARY)
FROM TABLENAME
WHERE SALARY NOT IN ( SELECT MAX(SALARY) FROM TABLENAME);



3. Nth Highest Salary:
Syntax:
SELECT MIN(SALARY)
FROM TABLENAME
WHERE SALARY IN (SELECT TOP Nth SALARY FROM TABLENAME
ORDER BY SALARY DESC);


SELECT * FROM Customers
WHERE Country IN ('Germany', 'France', 'UK');


Ex: The following SQL statement selects all products with a price between 10 and 20:
SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20;


What is Partitioning in Databases?
Partitioning is the process of dividing a large table or index into smaller, more manageable pieces called partitions, 
while still treating it as a single entity. This technique improves query performance and maintenance by allowing operations 
to be executed on smaller subsets of data.

Key Benefits of Partitioning
Improved Query Performance:
Queries that target a specific partition (or a few partitions) are faster because the database scans only a subset of data.

Efficient Maintenance:
Operations like backups, archiving, or data purging can be performed on individual partitions rather than the entire table.

Scalability:
Large tables can be managed more effectively by dividing them into logical segments.


Imagine a table sales that stores data for each sale transaction over several years. To improve performance and manageability, 
you can partition this table by year.

Create the Partitioned Table:
Use Range Partitioning based on a date column.

sql
Copy
Edit
CREATE TABLE sales (
    sale_id INT AUTO_INCREMENT PRIMARY KEY,
    sale_date DATE,
    amount DECIMAL(10,2),
    customer_id INT
)
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION pFuture VALUES LESS THAN MAXVALUE
);

Explanation:
PARTITION BY RANGE (YEAR(sale_date)):
Divides the table based on the year extracted from sale_date.

PARTITION p2020 VALUES LESS THAN (2021):
Stores sales data for the year 2020.

PARTITION p2021 VALUES LESS THAN (2022):
Stores sales data for the year 2021.

PARTITION p2022 VALUES LESS THAN (2023):
Stores sales data for the year 2022.

PARTITION pFuture VALUES LESS THAN MAXVALUE:
Catches any sales records with years beyond 2022.

Inserting Data:
Insert data into the sales table as usual. The database automatically routes each row to the correct partition based on the sale date.

sql
INSERT INTO sales (sale_date, amount, customer_id) 
VALUES ('2021-06-15', 250.00, 101);
Querying the Partitioned Table:
When you query data with a filter on sale_date, MySQL can quickly narrow down the relevant partition(s):

sql
SELECT * FROM sales 
WHERE sale_date BETWEEN '2021-01-01' AND '2021-12-31';
Result:
MySQL only scans the partition p2021, thus speeding up the query.
